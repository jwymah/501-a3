import java.beans.PropertyEditor;
import java.beans.PropertyEditorManager;
import java.io.File;
import java.io.OutputStream;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.input.SAXBuilder;
import org.jdom2.output.Format;
import org.jdom2.output.XMLOutputter;

/*
 * This Java source file was auto generated by running 'gradle buildInit --type java-library'
 * by 'bighoon' at '06/11/15 10:16 PM' with Gradle 2.6
 *
 * @author bighoon, @date 06/11/15 10:16 PM
 */
public class Deserializer {
	Map<String, Object> deserializedMap = new HashMap<>();
	Element rootNode;
	
    public Deserializer()
    {
    	try
		{
    		File file = new File("classB.txt");
    		
    		SAXBuilder saxBuilder = new SAXBuilder();
    		Document doc = saxBuilder.build(file);

    		rootNode = doc.getRootElement();
    		
    		for (Element element : rootNode.getChildren())
    		{
    			// create objects for every child of root element
    			if (deserializedMap.get(element.getAttribute("class")) != null)
    			{
    				continue; // because it may have already been instantiated due to being pointed to by another object
    			}
    			
    			deserialize(element);
    		}
    		
    		for (Entry<String, Object> entry : deserializedMap.entrySet())
    		{
    			System.out.println("{"+entry.getKey() + "," + entry.getValue()+"}");
    			for (Field f : entry.getValue().getClass().getDeclaredFields())
    			{
    				f.setAccessible(true);
    				System.out.println(f.get(entry.getValue()));
    			}
    		}
    		
    		ClassB b = (ClassB) deserializedMap.get("0");
    		System.err.println(b.int1);
    		
//    		MySerializer mySerializer = new MySerializer();
//    		Element reserialized = mySerializer.serialize(deserializedMap.get("0"));
//    		System.out.println("\n\n\n\n IT STARTS NOW");
//    		System.out.println(reserialized.getTextNormalize());
    		
		}
		catch (Exception e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    }

	private void deserialize(Element element) throws ClassNotFoundException, NoSuchMethodException
	{
		if (element.getAttribute("length") != null)
		{
			System.out.println("DESERIALIZING ARRAY: " + element.getAttributeValue("class")
								+ " ID: " + element.getAttributeValue("id"));
			// TODO: stubbed
			Object newArray = getComponentType(element.getAttributeValue("class"), Integer.parseInt(element.getAttributeValue("length")));
//			Object newArray = Array.newInstance(componentType, Integer.parseInt(element.getAttributeValue("length")));
			deserializedMap.put(element.getAttributeValue("id"), newArray);
//			java.lang.reflect.Array.newInstance(Class<?> componentType, int length)
		}
		else
		{
			Class<?> classObj = Class.forName(element.getAttributeValue("class"));
			classObj.getDeclaredConstructor(null).setAccessible(true);
			Object classInstance = null;
			try
			{
				classInstance = classObj.newInstance();
				deserializedMap.put(element.getAttributeValue("id"), classInstance);
				System.err.println("adding to map: {" + element.getAttributeValue("id") + "," + classInstance + "}");
				
				System.err.println("Serializing: " + classInstance.getClass() + " ID: " + element.getAttributeValue("id"));
				
				setFields(element, classObj, classInstance);
			}
			catch (InstantiationException | IllegalAccessException e)
			{
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}

	private void setFields(Element element, Class<?> classObj, Object classInstance)
	{
		// all of the element's children are fields
		for (Element child : element.getChildren())
		{
			String fieldName = child.getAttributeValue("name");
			String value = child.getChildren().get(0).getText();
			
			System.out.println("setting field on id {"+element.getAttributeValue("id")+"} " + classObj.toString() + ":" + fieldName + " --> " + value);
			try
			{
				Field field = classObj.getDeclaredField(fieldName);
				field.setAccessible(true);

				// field == null or reference or primitive
				if (value == null)
				{
					//nothing
				}
				else if (child.getChildren().get(0).getName() == "reference")
				{
					//TODO: find the object's reference in map if already created
					// otherwise go and create it...
					// or is there a better way?
					System.err.println("is a reference with value: " + value);
					if (deserializedMap.get(value) != null)
					{
						System.err.println("EVEEEEEEEEEEEEEEEEEEEEEE"); //TODO: make sure this works
						field.set(classInstance, deserializedMap.get(value));
					}
					else
					{
						// go deserialize a specific object...
						// go recursive and put this call onto the stack
						for (Element searchElement : rootNode.getChildren())
						{
							if (searchElement.getAttributeValue("id").compareTo(value) == 0)
							{
								System.err.println("FOUND IT... now go deserialize it");
								System.out.print("key set size: ");
								System.out.println(deserializedMap.size());
								
								try
								{
									deserialize(searchElement);
								}
								catch (ClassNotFoundException | NoSuchMethodException e)
								{
									// TODO Auto-generated catch block
									e.printStackTrace();
								}
								field.set(classInstance, deserializedMap.get(value));
								System.err.println("stored in map as: " + deserializedMap.get(value));
								
								for (Object object : deserializedMap.keySet())
								{
									System.out.println("----"+object.getClass().toString());
									System.out.println("--" + object);
									System.out.println("-" + deserializedMap.get(value));
									System.out.println("value: " + value + " key: " + object);
								}
								break;
							}
						}
					}
				}
				else // primitive that is not null
				{
					field.set(classInstance, convert(field.getType(), value));
				}
			}
			catch (NullPointerException e)
			{
				System.err.println("is this still being hit?");
				System.err.println(child.getChildren().get(0).getName());
				e.printStackTrace();
			}
			catch (NoSuchFieldException | IllegalAccessException e)
			{
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		System.out.print("key set size: ");
		System.out.println(deserializedMap.size());
	}
    
    // from the second answer on 
    // http://stackoverflow.com/questions/13943550/how-to-convert-from-string-to-a-primitive-type-or-standard-java-wrapper-types
    private Object convert(Class<?> targetType, String text) {
        PropertyEditor editor = PropertyEditorManager.findEditor(targetType);
        editor.setAsText(text);
        return editor.getValue();
    }

	private Object getComponentType(String className, int length) throws ClassNotFoundException{
		if("[I".equals(className)) return Array.newInstance(int.class, length);
		if("[D".equals(className)) return double.class;
		if("[F".equals(className)) return float.class;
		if("[B".equals(className)) return byte.class;
		if("[J".equals(className)) return long.class;
		if("[S".equals(className)) return short.class;
		if("[Z".equals(className)) return boolean.class;
		if("[C".equals(className)) return char.class;
		// remove Leading [L and trailing ;
		return Array.newInstance(Class.forName(className.substring(2,className.length()-1)), length);
	}
    
    public static void main(String[] args)
    {
    	Deserializer deserializer = new Deserializer();
    }
}
