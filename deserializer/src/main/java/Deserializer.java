import java.beans.PropertyEditor;
import java.beans.PropertyEditorManager;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.Field;
import java.util.IdentityHashMap;

import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.JDOMException;
import org.jdom2.input.SAXBuilder;

/*
 * This Java source file was auto generated by running 'gradle buildInit --type java-library'
 * by 'bighoon' at '06/11/15 10:16 PM' with Gradle 2.6
 *
 * @author bighoon, @date 06/11/15 10:16 PM
 */
public class Deserializer {
	IdentityHashMap<Object, Object> deserializedMap = new IdentityHashMap<>();
    public Deserializer()
    {
    	try
		{
    		File file = new File("classB.txt");
    		
    		SAXBuilder saxBuilder = new SAXBuilder();
    		Document doc = saxBuilder.build(file);

    		Element rootNode = doc.getRootElement();
    		
    		for (Element element : rootNode.getChildren())
    		{
    			// create objects for every child of root element
    			if (deserializedMap.get(element.getAttribute("class")) != null)
    			{
    				continue; // because it may have already been instantiated due to being pointed to by another object
    			}
    			
    			if (element.getAttribute("length") != null)
    			{
    				System.out.println("DESERIALIZING ARRAY: " + element.getAttributeValue("class")
    									+ " ID: " + element.getAttributeValue("id"));
    			}
    			else
    			{
	    			Class<?> classObj = Class.forName(element.getAttributeValue("class"));
	    			classObj.getDeclaredConstructor(null).setAccessible(true);
	    			Object newInstance = null;
	    			try
					{
						newInstance = classObj.newInstance();
						deserializedMap.put(element.getAttribute("id"), newInstance);
						
						System.err.println("Serializing: " + newInstance.getClass() + " ID: " + element.getAttributeValue("id"));
						
						// all of the element's children are fields
						for (Element child : element.getChildren())
						{
							String fieldName = child.getAttributeValue("name");
							String value = child.getChildren().get(0).getText();
							
							System.out.println("setting field on id {"+element.getAttributeValue("id")+"} " + classObj.toString() + ":" + fieldName + " --> " + value);
							try
							{
								Field field = classObj.getDeclaredField(fieldName);
								field.setAccessible(true);
								
								if (child.getChildren().get(0).getName() == "reference")
								{
									//TODO: find the object's reference in map if already created
									// otherwise go and create it...
									// or is there a better way?
									if (deserializedMap.get(child.getAttribute("id")) != null)
									{
										field.set(newInstance, deserializedMap.get(child.getAttribute("id")));
									}
									else
									{
										// go deserialize a specific object
									}
									
								}
								else
								{
									field.set(newInstance, convert(field.getType(), value));
								}
							}
							catch (NullPointerException e)
							{
								System.err.println(child.getChildren().get(0).getName());
								e.printStackTrace();
							}
							catch (NoSuchFieldException | IllegalAccessException e)
							{
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
						}
					}
					catch (InstantiationException | IllegalAccessException e)
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
    			}
    		}
		}
		catch (FileNotFoundException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		catch (IOException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		catch (JDOMException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		catch (ClassNotFoundException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		catch (SecurityException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		catch (NoSuchMethodException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    }
    
    // from the second answer on 
    // http://stackoverflow.com/questions/13943550/how-to-convert-from-string-to-a-primitive-type-or-standard-java-wrapper-types
    private Object convert(Class<?> targetType, String text) {
        PropertyEditor editor = PropertyEditorManager.findEditor(targetType);
        editor.setAsText(text);
        return editor.getValue();
    }
    
    public static void main(String[] args)
    {
    	Deserializer deserializer = new Deserializer();
    }
}
